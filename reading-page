import { useMemo, useState, useEffect } from "react";

const ReadingPage = () => {
  const [currentWordIdx, setCurrentWordIdx] = useState(0);
  const [speed, setSpeed] = useState(1);
  const [phrase, setPhrase] = useState("This book is largely concerned with Hobbits, and from its pages a reader may discover much of their character and a little of their history. Further information will also be found in the selection from the Red Book of Westmarch that has already been published, under the title of The Hobbit. That story was derived from the earlier chapters of the Red Book, composed by Bilbo himself, the first Hobbit to become famous in the world at large, and called by him There and Back Again, since they told of his journey into the East and his return: an adventure which later involved all the Hobbits in the great events of that Age that are here related. Many, however, may wish to know more about this remarkable people from the outset, while some may not possess the earlier book. For such readers a few notes on the more important points are here collected from Hobbit-lore, and the first adventure is briefly recalled.");
  const phraseAsArray = useMemo(() => phrase.split(" "), [phrase]);

  // Find the max word length in the phrase for centering
  const maxWordLength = useMemo(() => {
    return phraseAsArray.reduce((max, w) => Math.max(max, w.length), 0);
  }, [phraseAsArray]);

  // Calculate interval in ms: higher speed = faster (e.g. 1 = slowest, 5 = fastest)
  const speedToMs = (speed: number) => 600 - (speed - 1) * 120; // 600ms to 120ms

  useEffect(() => {
    if (currentWordIdx >= phraseAsArray.length - 1) return;
    const timeout = setTimeout(() => {
      setCurrentWordIdx((idx) =>
        idx < phraseAsArray.length - 1 ? idx + 1 : idx
      );
    }, speedToMs(speed));
    return () => clearTimeout(timeout);
  }, [currentWordIdx, speed, phraseAsArray.length]);

  // Reset index if phrase changes
  useEffect(() => {
    setCurrentWordIdx(0);
  }, [phrase]);

  // Highlight middle letter in red, center it in a fixed-width, monospace container
  const renderWord = (word: string) => {
    if (!word) return null;
    const len = word.length;
    const mid = Math.floor((len - 1) / 2);
    // Pad word so that the highlighted letter is always at the center of the max length
    const totalSlots = maxWordLength;
    const centerIdx = Math.floor((totalSlots - 1) / 2);
    const leftPad = Math.max(centerIdx - mid, 0);
    const rightPad = Math.max(totalSlots - (leftPad + len), 0);
    const padded = [
      ...Array(leftPad).fill(" "),
      ...word.split("").map((char, i) => ({ char, isMid: i === mid })),
      ...Array(rightPad).fill(" "),
    ];
    return (
      <span
        className="inline-flex justify-center items-center w-full h-full font-mono text-3xl tracking-widest"
        style={{ minWidth: `${maxWordLength}ch` }}
      >
        {padded.map((item, i) =>
          typeof item === "string" ? (
            <span key={i} className="opacity-0 select-none">_</span>
          ) : item.isMid ? (
            <span key={i} className="text-red-500 font-bold">{item.char}</span>
          ) : (
            <span key={i}>{item.char}</span>
          )
        )}
      </span>
    );
  };

  return (
    <div className="w-full">
      <div className="flex flex-col gap-8 items-center">
        <div className="relative w-full flex justify-center items-center h-40 bg-black text-white p-12 select-none">
          <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2">
            {renderWord(phraseAsArray[currentWordIdx])}
          </div>
        </div>
        <button className="px-3 py-1 rounded border-1" onClick={() =>setCurrentWordIdx(0)}>
          Restart
        </button>
        <label className="flex flex-col items-start gap-2">
          <span className="text-sm">Speed: {speed}</span>
          <input
            type="range"
            className="w-64"
            value={speed}
            min={1}
            max={5}
            onChange={(e) => setSpeed(Number(e.target.value))}
          />
        </label>
        <textarea
          className="w-64 border-2 rounded p-4"
          value={phrase}
          onChange={(e) => setPhrase(e.target.value)}
        ></textarea>
      </div>
    </div>
  );
};

export default ReadingPage;
